---

layout: post
tag: Study
title: 胡诌八扯
date: 2020-03-06
cover: 

---

# **胡诌八扯**  

&#8195;  

>&#8195;由于某些不可明说的个人原因，外加众所周知的不可抗力，目前该学习计划进展缓慢（说白就是赶不上ddl了  

&#8195;


### **CPU与物理核心**

CPU即为中央处理器(*Central Processing Unit*)的缩写，顾名思义，它就是计算机系统的执行单元。

核心,即是CPU中独立物理封装的微处理器。

一般来说，个人设备配备单CPU，物理核心数从1到32不等；而高端服务器配备多CPU，每个CPU的物理核心数在32个左右。



### **物理核心与逻辑核心**
![avatar](https://raw.githubusercontent.com/MinerOAO/MinerOAO.github.io/master/assets/img/P1.png)  
>&#8195;刚开始一直用“线程”指代逻辑核心，后来读着读着自己都快给绕晕了。   想了好久终于搞明白了此线程非彼线程，那么“线程”一词就专门指代操作系统层面的线程了。  
>&#8195;这下终于有点理解任务管理器里那些奇怪的翻译了

大概在二十年前，你有多少个物理核心，就有多少个逻辑核心。也就是说，n个物理核心对应n个逻辑核心，你的CPU就能够同时处理n个线程。(俗称为n核n线程CPU)

但是，大人，时代变了！

2002年，英特尔公布了超线程(*Hyper  Threading,HT*)技术.

何谓超线程技术？简单的说即是，使任意一个物理核心在任意一个极短的时间间隔内，近乎同时执行两个线程。而在用户看来，他便拥有了两个逻辑核心，能够“同时”处理两个线程。

如何做到呢？

首先，这两个逻辑核心共享的资源有： 执行引擎  高速缓存(*Cache*)  系统总线接口......  
但却拥有各自独立的逻辑核心状态储存设施：控制寄存器 通用寄存器......  

可以看到，HT技术并没有增多物理核心中的计算资源，而更像是优化了资源调度的方式。它使得操作系统的调度器能够同时调度两个逻辑核心。但不要忘了，它们仍然属于同一个物理核心。两个逻辑核心的同时调度，大大缩短了一个物理核心在不同线程间切换的时钟周期，在宏观上就反映为“同时执行两个线程”。


### **逻辑核心与线程 线程与进程**

从这里开始，所涉及的知识开始包括软件方面了。  
先来看一些基本概念

进程(*Process*)：操作系统进行资源分配和调度的最小单位，一个进程可以拥有多个线程。  
线程(*Thread*)：操作系统进行运算调度的最小单位.

联系之前提到的逻辑核心，我们大概可以看出，线程即是进程中可以派遣的工作单位，进程将一个线程交由一个逻辑核心进行运算。

而如果，多个线程同时交由多个逻辑核心进行运算，在物理层面上被"***同时刻执行***"，这样的计算方式称作并行。  

再往下说，如果进程数量再大一些，线程数量再多一些，以致于超过了你所拥有的逻辑核心数量呢？
很显然，多个任务不能被同时处理了，也算不上是并行了。 


此时，操作系统便把CPU的工作时间分为几个时间段，一个时间段运行一个线程，而那些在队列中的线程便处于挂起状态。
像这样，有多个任务“***同时段发生***”，也即同时段存在，便被称为并发。


 

    
### **进程切换（施工中）**
SCHED_OTHER  
SCHED_RR 轮转法RR  
SCHED_FIFO 先进先出FIFO   



### **守护进程**
何谓守护进程(*Daemon*)？  
守护进程实际上是一类特殊进程，它通常用以处理一些周期性任务，或者，为某些尚未发生的事件待命。而它的特殊点在于后台运行，并且脱离终端的控制。这样的特性，使得它在执行过程中产生的信息不会在终端上显示，并且也不会受到终端的干扰。

通过以下步骤，可以将普通进程改造为守护进程:

>**1.创建子进程,父进程退出  
2.建立会话期session  
3.改变工作目录  
4.重设文件创建掩码umask**  

 *此时子进程成为一个孤儿进程，由 ID为 1 的 init 进程收养*


### **锁（施工中）**
